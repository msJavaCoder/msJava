# 线程池

## 1.线程池工作原理

> JVM先根据用户的参数创建一定数量的可运行的线程任务，并将其放入队列中，在线程创建后启动这些任务，如果正在运行的线程数量超过了最大线程数量（用户设置的线程池大小），则超出数量的线程排队等候，在有任务执行完后，线程池调度器会发现有可用的线程，进而再次从队列中取出任务并执行。

## 2.线程池的核心组件和核心类、

**核心组件**

+ 线程池管理器：用户创建并管理线程池。
+ 工作线程：线程池中执行具体任务的线程。
+ 任务接口：用于定义工作线程的调度和执行策略，只有线程实现了该接口，线程中的任务才能够被线程池调度。
+ 任务队列：存放待处理的任务，新的任务会不断被加入队列中，执行完成的任务将被从队列移除。

**核心类**

+ Executor
+ Executors
+ ExecutorService
+ ThreadPoolExecutor
+ Callable
+ Future
+ FutureTask

**ThreadPoolExecutor**是构建线程的核心方法：

```java
 public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
             Executors.defaultThreadFactory(), defaultHandler);
    }
```

**ThreadPoolExecutor构造函数的具体参数**

| 序号 |      参数       |                             说明                             |
| :--: | :-------------: | :----------------------------------------------------------: |
|  1   |  corePoolSize   |                    线程池中核心线程的数量                    |
|  2   | maximumPoolSize |                    线程池中最大线程的数量                    |
|  3   |  keepAliveTime  |     当前线程池数量超过corePoolSize是，空闲线程的存活时间     |
|  4   |      unit       |                   keepAliveTime的时间单位                    |
|  5   |    workQueue    |         任务队列，被提交但尚未被执行的任务存放的地方         |
|  6   |  threadFactor   | 线程工厂，用于创建线程，可使用默认的线程工厂或自定义线程工厂 |
|  7   |     handler     |   由于任务过多或其他原因导致线程池无法处理时的任务拒绝策略   |

## 3.线程池的工作流程

​	**Java线程池的工作流程为：线程池刚被创建时，只是向系统申请一个用于执行线程队列和管理线程池的线程资源。在调用execute()添加一个任务时，线程池会按照以下流程执行任务。**

+ 如果正在运行的线程数量少于corePoolSize（用户自定义的核心线程数），线程池就会立刻创建线程并执行该线程任务。
+ 如果正在运行的线程数量大于等于corePoolSize（用户自定义的核心线程数），该任务就将被放入阻塞队列中。
+ 在阻塞队列已满且正在运行的线程数量小于 maximumPoolSize时，线程池会创建被非核心线程立即执行该线程任务。
+ 在阻塞队列已满且正在运行的线程数量大于等于 maximumPoolSize时，线程池将拒绝执行该线程任务并抛出RejectExecutionException异常。
+ 在线程任务执行完毕后，该任务将被从线程池队列中移除，线程池将从队列中取下一个线程任务继续执行。
+ 在线程处于空闲状态的时间超过keepAliveTime时间时，正在运行的线程数量超过corePoolSize，该线程将会认定为空闲线程并停止。因此在线程池中所以线程任务都执行完毕后，线程池会收缩到corePoolSize大小。

## 4.线程池的拒绝策略

**若线程池中的核心线程数被用完且阻塞队列已排满，则此时线程池的资源已耗尽，线程池将没有足够的线程资源执行新的任务。为了保证操作系统的安全，线程池将通过拒绝策略处理新添加的线程任务。**

| 序号 |        名称         |                             说明                             |
| :--: | :-----------------: | :----------------------------------------------------------: |
|  1   |     AbortPolicy     |                直接抛出异常，阻止线程正常运行                |
|  2   |  CallerRunsPolicy   |        如果被丢弃的线程任务未关闭，则执行该线程任务。        |
|  3   | DiscardOldestPolicy |    移除线程队列中最早的一个线程任务，并尝试提交当前任务。    |
|  4   |    DiscardPolicy    | 丢弃当前的线程任务而不做任何处理。如果系统允许在资源不足的情况相下丢弃部分任务，则这将是保障系统安全、稳定的一种很好的方案。 |
|  5   |   自定义拒绝策略    | 以上四种拒绝策略无法满足实际需要，用户可以扩展RejectedExecutionHandler接口实现拒绝策略。 |

## 5.五种常用的线程池

| 序号 |          名称           |             说明             |
| :--: | :---------------------: | :--------------------------: |
|  1   |       AbortPolicy       |        可缓存的线程池        |
|  2   |   newFixedThreadPool    |       固定大小的线程池       |
|  3   | newScheduledThreadPool  |     可做任务调度的线程池     |
|  4   | newSingleThreadExecutor |       单个线程的线程池       |
|  5   |   newWorkStealingPool   | 足够大小的线程池，JDK1.8新增 |

## 6. 向线程池提交任务

- execute()方法：当提交不需要返回值的任务，缺点无法判断任务是否被线程池执行成功；
- submit()方法：当提交需要返回值的任务，此时线程池会返回一个future类型的对象，通过该对象可以判断线程池是否执行成功，并且可以通过调用该对象的get()方法获取返回值；

## 7. 关闭线程池

​		关闭线程池可以调用shutdown或者shutdownNow方法。区别如下：

- 共同点：
  - 它们的原理都是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程（ 无法响应中断的任务可能永远无法终止）。
- 不同点：
  - shutdownNow首先将线程池的状态设置为STOP，然后尝试停止所有的正在执行或暂停任务的线程。
  - shutdown只是将线程池的状态设置成SHOTDOWN状态，然后中断所有没有正在执行任务的线程。

**总结：通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。**

## 总结

**线程池的好处**

+  降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁的消耗。
+ 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
+ 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。  
# 01 | 栈：从简单栈到单调栈，解决经典栈问题

## 前言

栈这种数据结构，使用是非常广泛的，比如我们Java中函数的调用、浏览器中的前进与后退功能、操作系统中从用户态到内核态寄存器的保存、网络消息的处理等都会用到栈。

## 如何理解栈？

如何去理解栈呢？其实非常简单，一句话可以概况栈的特性：**先进后出**，俗称“**出多了吐**”。

在Java中如何使用栈，代码如下：

```java
// 创建一个栈
Stack<Integer> stack = new Stack<Integer>();
// 想栈中放入4个元素
stack.push(1);
stack.push(2);
stack.push(3);
stack.push(4);

// 查看此时栈顶的元素
System.out.println(stack.peek());  // 输出结果：4 
// 将栈顶元素出站
System.out.println(stack.pop());  // 输出结果：4
// 再次查看此时栈顶元素
System.out.println(stack.peek());  // 输出结果：3 
// 再次将栈顶元素出站
System.out.println(stack.pop());   // 输出结果：3
```

## 如何实现栈？

实现栈的方式既可以选择数组，也可以链表。那么选择数组来实现的栈就叫做顺序栈，选择链表来实现的栈就叫做链式栈。

接下来，我们用Java代码分别实现**顺序栈**、**链式栈**。

### 顺序栈

```java
/**
 * @author 微信公众号：码上Java 
 * @Description: 用数组实现站结构
 */

public class MyArratStack<E> {

    private Object[] data = null;  // 泛型数组
    private int maxSize = 0;  //栈容量
    private int top = -1;  //栈顶指针

    /**
     * 初始化构造方法
     * @param initialSize 初始栈的容量
     */
    MyArratStack(int initialSize) {
        if (initialSize >= 0) {
            this.maxSize = initialSize;
            data = new Object[initialSize];
            top = -1;
        } else {
            throw new RuntimeException("初始化大小不能小于0: " + initialSize);
        }
    }

    /**
     * 初始化构造方法 默认栈容量为10
     */
    public MyArratStack() {
        this(10);
    }

    /**
     * 入栈操作
     * @param e 
     * @return
     */
    public boolean push(E e) {
        //首先判断一下栈是否已经满了
        if (top == maxSize - 1) {
            //可优化 TODO 扩容操作
            throw new RuntimeException("栈已满，元素无法入栈");
        } else {
            data[top] = e;
            top++;
            return true;
        }
    }

    /**
     * 出栈操作
     * @return
     */
    public E pop() {
        //首先查看一下栈是否为空
        if (top == -1) {
            throw new RuntimeException("栈为空 ");
        } else {
            //将栈顶元素返回后维护一下栈顶指针
            return (E) data[top--];
        }
    }

    /**
     * 查看栈顶元素
     * @return
     */
    public E peek() {
        if (top == -1) {
            throw new RuntimeException("栈为空");
        } else {
            // 查看栈顶元素并不移除所以说不需要维护栈顶指针
            return (E) data[top];
        }
    }

    /**
     * 判断栈是否为空
     * @return
     */
    public boolean isEmpty() {
        return maxSize == 0;
    }

}
```

### 链式栈

```java
```

### 小结

不管是顺序栈还是链式栈，因为栈本身的局限性，也就是一个口子，只能涉及到个别元素的操作，所以说时间复杂度都是O(1)。

还有一点你发现没有，顺序栈是存在一个扩容的问题，因为数组不像链表，链表只要你内存够大，是可以支持无限扩展的。但是数组就不一样了，因为数组本身大小是已经初始化好了的，如果数组满了的话，你是无法继续往栈中添加元素的。如果想要添加元素，就必须解决这个扩容的问题。

那么如何解决呢？无非就是创建一个更大点的新数组，将就旧数组的元素通过遍历放到新数组里面。此时的时间复杂度会变成O(n)了。

那么我们可以总结下，最好的情况是栈不满，时间复杂度是O(1)。最坏的情况是栈满了，时间复杂度是O(1)。

## 实践演练

###  判断字符串括号是否合法

题目描述：给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

+ 左括号必须用相同类型的右括号闭合。
+ 左括号必须以正确的顺序闭合。

**四步分析法：**

1. 模拟：模拟题目的运行。

2. 规律：尝试总结出题目的一般规律和特点。

3. 匹配：根据题目描述选择合适的算法与数据结构。

4. 边界：考虑特殊情况。






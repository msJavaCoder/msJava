# 理解HTTP与HTTPS

## HTTP 概况

> HTTP 即超文本传输协议，是 Web 的应用层协议。HTTP 由两个程序实现，一个客户程序和一个服务器
> 程序，客户程序和服务器程序运行在不同的端系统中，通过交换 HTTP 报文进行会话。HTTP 定义了这
> 些报文的结构以及客户和服务器进行报文交换的方式，当用户请求一个 Web 页面时，浏览器向服务器
> 发出对该页面中所包含对象的 HTTP 请求报文，服务器接收到请求并用包含这些对象的 HTTP 响应报文
> 进行响应。

**HTTP 使用 TCP 作为它的支撑运输协议**，HTTP 客户首先发起一个与服务器的 TCP 连接，一旦连接建
立，该浏览器和服务器进程就可以通过套接字访问 TCP。客户端的套接字接口是客户进程与 TCP 连接
之间的门，服务器端的套接字接口则是服务器进程与 TCP 连接之间的门。客户向它的套接字接口发送
HTTP 请求报文并从它的套接字接口接收 HTTP 响应报文，类似的，服务器从它的套接字接口接收
HTTP 请求报文并向它的套接字接口发送 HTTP 响应报文。一旦客户向它的套接字接口发送一个 HTTP
请求报文，该报文就脱离了客户控制并进入 TCP 的控制，TCP 为 HTTP 提供可靠的数据传输服务，因此
一个客户进程发出的每个 HTTP 请求报文最终都能完整地到达服务器，服务器进程发出地每个 HTTP 响
应报文最终也可以完整地到达客户。这里体现了分层体系结构的优点，HTTP 协议不需要担心数据丢
失，也不需要关注 TCP 从网络的数据丢失和乱序中如何恢复。

**HTTP 是一种无状态的协议**，服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。
假如某个客户在短时间内连续两次请求同一个对象，服务器并不会因为刚刚为该客户做出了响应就不再
响应，而是重新进行响应。

## 非持续连接和持续连接

依据每个请求/响应对经过一个单独的 TCP 连接还是相同的 TCP 连接发送，可以将连接划分为非持续连
接和持续连接。HTTP 默认使用持续连接，但是也可以配置成使用非持续连接。

**非持续连接**
使用非持续连接时，从服务器向客户传送一个包含了一个 HTML 文件和 10 个 JPG 对象的 Web 页面步
骤：
① HTTP 客户进程在端口号 80 发起一个到服务器的 TCP 连接，并经它的套接字向服务器发送一个
HTTP 请求报文。

② HTTP 服务器进程经它的套接字接收请求报文，从其存储器中检索出请求对象，在
一个 HTTP 响应报文中封装对象，并通过套接字向客户发送响应报文。

③ HTTP 服务器进程通知 TCP 断
开该 TCP 连接，直到 TCP 确认客户已经完整接收到响应报文才会实际断开连接。

④ HTTP 客户接收到
响应报文，客户从报文中提取出 HTML 文件，得到多个 JPG 图像的引用，并对每个引用的 JPG 图像对
象重复前三个步骤。

每个 TCP 连接会在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。每个 TCP 连
接只传输一个请求报文和一个响应报文，假如请求一个 HTML 文件和其中包括的 10 个 JPG 图像就要产
生 11 个 TCP 连接。

在非持续连接中，每次请求文件到接收响应大约需要花费两个 RTT 加上服务器传输文件的时间，RTT 就
是往返时间，指一个短分组从客户到服务器然后再返回客户所发送的时间。其中三次握手的前两个部分
占用一个 RTT，三次握手的第三个确认部分向服务器发送了请求报文，服务器接收到之后做出响应，这
用去了另一个 RTT。

## 持续连接

非持续连接有很多缺点。

第一，必须为每个请求的对象建立和维护一个新的连接，对于每个连接，在客
户和服务器中都要分配 TCP 的缓冲区和保持 TCP 变量，这给 Web 服务器带来了很大负担。

第二，每一个对象需要消耗两倍的 RTT，一个用于创建 TCP，一个用于请求和接收对象。

在 HTTP1.1 中使用了持续连接，服务器在发送响应后保持该 TCP 连接打开。在相同的客户与服务器之
间，后续的请求和响应报文能够通过相同的连接进行传送。在使用持续连接的情况下，请求一个完整的
Web 页面可以使用单个持续的 TCP 连接，例如之前所说的包含一个 HTML 文件和 10 个 JPG 对象的
Web 页面就只需要一个 TCP 连接而不是 11 个。

## HTTP 报文格式

HTTP 报文有两种，分为请求报文和响应报文。

**请求报文**

HTTP 请求报文的第一行叫做请求行，其后继的行叫做首部行。请求行有三个字段，包括方法、URL 和
HTTP 版本。方法包括了 GET、POST、HEAD、PUT 和 DELETE 等。绝大部分的 HTTP 请求报文使用
GET 方法，当使用 GET 方法时，在 URL 字段中会带有请求对象的标识。

首部行指明了对象所在的主机，其实已经存在 TCP 连接了，但是还需要首部行提供主机信息，这时
Web 代理高速缓存所要求的。通过包含  `Connection:close `的首部行，可以告诉服务器不要麻烦地使
用持续连接，它要求在发送完响应后就关闭连接。 `User-agent `可以用来指明用户代理，即向服务器发
送请求的浏览器类型，服务器可以有效地为不同类型的用户代理发送实际相同对象的不同版本。

在首部行之后有一个空行，后面跟着的是实体。使用 GET 方法时实体为空，而使用 POST 方法时才会
使用实体。当用户提交表单时，HTTP 客户通常使用 POST 方法，使用 POST 方法时用户仍可以向服务
器请求一个 Web 页面，但 Web 页面的特定内容依赖于用户在表单字段中输入的内容。如果使用 POST
方法，则实体中包含的就是用户在表单字段的输入值。表单不是必须使用 POST 方法，也可以使用
GET。

HEAD 方法类似于 GET，当服务器收到一个使用 HEAD 方法的请求时，将会用一个 HTTP 报文进行响
应，但是并不返回请求对象。通常开发者使用 HEAD 方法进行调试跟踪。PUT 方法常用于上传对象到
指定的 Web 服务器上指定的目录，DELETE 方法允许用户或应用程序删除 Web 服务器上的对象。

**响应报文**

响应报文包括状态行、首部行和实体。状态行有三个字段，协议版本、状态码和对应的状态信息。实体
是报文的主要部分，即所请求的对象本身。

服务器通过首部行来告诉浏览器一些信息。  `Connection:close `可以告诉客户发送完报文后将关闭该
TCP 连接。 Date 是首部行指示服务器发送响应报文的日期和时间，这个时间不是对象创建或修改的时
间，而是服务器从它的文件系统中检索到该对象，将该对象插入响应报文并发送的时间。 Server 指明
了服务器的类型，类似于请求报文中的  `User-agent `。

## cookie

HTTP 的无状态性简化了服务器的设计，并且提高了 Web 服务器的性能，使其可以同时处理大量的
TCP 连接。但是一个 Web 站点通常希望能够识别用户，可能是为了限制用户的访问，也可能为了把内
容与用户身份关联起来，为此 HTTP 使用了 cookie，cookie 是一种客户端的会话技术，允许站点对用
户进行追踪。

cookie 技术有四个组件

① 在 HTTP 响应报文中的一个 cookie 首部行。

② 在 HTTP 请求报文中的一个 cookie 首部行。

③ 在用户端系统中保留有一个 cookie 文件，并由用户的浏览器关联。

④ 位于 Web 站点的一个后端数据库。cookie 的工作流程：当客户通过浏览器第一次访问某个站点时，

该 Web 站点将产生一个唯一识别码，并以此作为索引在它的后端数据库中产生的一个表项。接下来服务

器会用一个包含  Set-cookie 首部的HTTP 响应报文对浏览器进行相应，当浏览器收到后将其添加到自己

管理的 cookie 文件中，在下次访问该站点时，请求报文的首部行中就会包括这个识别码，尽管浏览器不

知道客户是谁，但是可以确定是同一个客户进行了访问。

**cookie 和 session 的区别**

① cookie 只能存储 ASCII 码字符串，而 session 则可以存储任何类型的数据，因此在考虑数据复杂性
时首选session。

② session 存储在服务器，而 cookie 存储在客户浏览器中，容易被恶意查看。如果非
要将一些隐私数据存在 cookie 中，可以将 cookie 值进行加密，然后在服务器进行解密。

## Web 缓存

Web 缓存器也叫代理服务器，它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体。Web 缓存
器有自己的磁盘存储空间，并在存储空间中保存最近请求过的对象副本。可以配置用户的浏览器，使得
用户所有的 HTTP 请求首先指向 Web 缓存器。客户通过 Web 缓存器请求对象的步骤如下：
① 浏览器创建一个到 Web 缓存器的 TCP 连接，并向 Web 缓存器中的对象发送一个 HTTP 请求。

②Web 缓存器进行检查，查看本地是否存储了该对象副本。如果有，Web 缓存器就向客户浏览器用
HTTP 响应报文返回该对象。

③ 如果 Web 缓存器中没有该对象，它就打开一个与该对象的初始服务器
的 TCP 连接，Web 缓存器在这个连接上发送一个请求并接受响应。

④ Web 缓存器接收到响应后，在本地存储空间存储一份副本，并向客户的浏览器用 HTTP 响应报文发送该副本。

Web 缓存器既是服务器又是客户，当它接受浏览器的请求并响应时，它是一个服务器，当他向初始服
务器发出请求并接收响应时，它是一个客户。在因特网上部署 Web 缓存器有两个原因，首先，Web 缓
存器可以大大减少对客户请求的响应时间，特别是客户与初始服务器之间的带宽远低于客户与 Web 缓
存器之间的带宽时更是如此。其次，Web 缓存器可以大大减少一个机构的接入链路到因特网的通信
量，通过减少通信量，机构就不必基于增加带宽，可以降低费用。

## 输入一个 url 发生的事

**① 分析 url**
判断输入的 url 是否合法，如果不合法浏览器会使用默认的搜索引擎进行搜索。如果输入的是一个域
名，默认会加上一个 http 前缀。

**② DNS 查询**
检查浏览器的 DNS 缓存，检查本地 hosts 文件的缓存，如果没有会向本地 DNS 服务器发送请求。
主机向本地 DNS 服务器发起请求是递归查询，如果找到则返回，否则会向根 DNS 查询。
根 DNS 查询是迭代查询，没有域名和 ip 的对应关系，而是告知可以查询的域名服务器地址。
本地 DNS 向得到的域名服务器发出请求，收到一个域名和 ip 关系，把结果返回给用户，并把结果保存
到缓存中。

**③ TCP 建立连接**
拿到 ip 地址后，通过 TCP 的三次握手建立连接，按照协议规定的格式发送 HTTP 请求报文。

**④ 处理请求**
服务器收到 HTTP 请求报文后进行响应，主进程进行监听，创建子进程处理，先判断是否是重定向，如
果是重定向则返回重定向地址。如果是静态资源则直接返回，否则通过 REST URL 在代码层面处理返回
结果，最后返回 HTTP 响应报文。

**⑤ 接收响应**
浏览器收到 HTTP 响应报文后进行解析，首先查看响应报文在状态行的状态码，根据不同的状态码做不
同的事，解析 HTML、CSS、JS 等文件。构建 DOM 树，渲染树，重绘，将像素发送 GPU 进行渲染，最
后将渲染结果返回给用户并进行缓存。

**⑥ TCP 断开连接**
通过 TCP 的四次挥手断开连接，如果是 HTTP1.1 则会将连接保持一小段时间。

## HTTPS

**HTTP 存在的问题**

HTTP 没有密码加密，无法保证通信内容不被窃听，攻击者可以截取客户发送的数据并得到他的信息。

HTTP 没有报文完整性验证，无法确保通信内容在传输过程中不被改变，攻击者可以篡改客户通信内
容。

HTTP 没有身份鉴别，无法让通信双方确认对方的身份，攻击者可以伪装成客户或者服务器。

**加密原理**

HTTPS 即 HTTP over SSL，在 HTTP 传输上增加了 SSL 安全性服务。SSL 是安全套接字层，通过采用机
密性、数据完整性、服务器鉴别以及客户鉴别来强化 TCP，主要用于为发生在 HTTP 之上的事务提供安
全性。SSL 会对数据进行加密并把加密数据送往 TCP 套接字，在接收方，SSL 读取 TCP 套接字中的数
据并解密，然后把数据交给应用层。HTTPS 采用混合加密机制，使用非对称加密传输对称密钥来保证传
输过程的安全性，之后使用对称加密进行通信来保证通信过程的效率。
HTTPS 的传输过程主要分为两部分：通过 SSL 握手建立安全的 HTTPS 通道和在安全的通道上进行数据
传输，SSL 握手的步骤如下：
① 客户发送它支持的密码算法列表，以及一个客户的不重数，不重数就是在一个协议的生存期只使用一
次的数。
② 服务器从该列表中选择一种对称加密算法（例如 AES），一种公钥加密算法（例如 RSA）和一种报
文鉴别码算法。服务器把它的选择以及证书和一个服务器不重数返回给客户。
③ 客户通过 CA 提供的公钥验证该证书，验证成功后提取服务器的公钥，生产一个前主密钥 PMS，用
服务器的公钥加密该 PMS，并将加密的 PMS 发送给服务器。
④ 客户和服务器独立地从 PMS 和不重数中计算出仅用于当前 SSL 会话的主密钥 MS，然后该 MS 被切
片以生成两个密码和两个报文鉴别码密钥。自从以后，客户和服务器之间发送的所有报文均被加密和鉴
别（使用报文鉴别码）。
⑤ 客户和服务器分别发送所有握手报文的一个报文鉴别码。这一步是为了使握手免受篡改危害，在第一
步中客户提供的算法列表是以明文形式发送的，因此可能被攻击者截获并删除较强的算法。当客户发送
一个级联它以及发送和接收的所有握手报文的报文鉴别码，服务器能够比较这个报文鉴别码和它已经接
受和发送的握手报文的报文鉴别码，如果不一致就终止连接。类似的，客户也可以通过服务器发送的报
文鉴别码来检查一致性。
第一步和第二步中的不重复数用于防止重放攻击，每个 TCP 会话使用不同的不重复数就可以使加密密钥
不同，当收到重放的 SSL 记录时，该记录无法通过完整性检查，假冒的电子事务不会成功。
当结束 SSL 会话时，需要在类型字段中指出该记录是否是用于终止 SSL 会话的。通过包含这样一个字
段，如果客户或服务器在收到一个关闭 SSL 记录之前突然收到了一个 TCP FIN，就知道遭受了截断攻
击。
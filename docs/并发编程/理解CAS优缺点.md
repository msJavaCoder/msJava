# CAS有很多优点,但它的缺点呢？

> 本文我们一起学习探讨CAS的缺点。

在面试中，面试官常问是了解CAS吗？它有什么优点？你可能一听，这多简单，我会！于是你就开始噼里啪啦说可以避免加互斥锁，可以提高程序的运行效率等。

但是CAS 的缺点，你知道吗？因为对于开发人员来说，对于任何一门技术或者某个知识点，我们都应该熟悉它的优缺点及适合的应用场景，这样才能写出更优雅且高效的代码了。

首先，我们就来看一下 CAS 有哪几个主要的缺点。

## ABA 问题
**首先，CAS 最大的缺点就是 ABA 问题。**

决定 CAS 是否进行 swap 的判断标准是“当前的值和预期的值是否一致”，如果一致，就认为在此期间这个数值没有发生过变动，这在大多数情况下是没有问题的。

但是在有的业务场景下，我们想确切知道从上一次看到这个值以来到现在，这个值是否发生过变化。例如，**这个值假设从 A 变成了 B，再由 B 变回了 A，此时，我们不仅认为它发生了变化，并且会认为它变化了两次。**

在这种场景下，我们使用 CAS，就看不到这两次的变化，因为仅判断“当前的值和预期的值是否一致”就是不够的了。CAS 检查的并不是值有没有发生过变化，而是去比较这当前的值和预期值是不是相等，如果变量的值从旧值 A 变成了新值 B 再变回旧值 A，由于最开始的值 A 和现在的值 A 是相等的，所以 CAS 会认为变量的值在此期间没有发生过变化。所以，CAS 并不能检测出在此期间值是不是被修改过，它只能检查出现在的值和最初的值是不是一样。

**那么如何解决这个问题呢？添加一个版本号就可以解决。**

我们在变量值自身之外，再添加一个版本号，那么这个值的变化路径就从 A→B→A 变成了 1A→2B→3A，这样一来，就可以通过对比版本号来判断值是否变化过，这比我们直接去对比两个值是否一致要更靠谱，所以通过这样的思路就可以解决 ABA 的问题了。

## 自旋时间过长

**CAS 的第二个缺点就是自旋时间过长。**

由于单次 CAS 不一定能执行成功，所以 CAS 往往是配合着循环来实现的，有的时候甚至是死循环，不停地进行重试，直到线程竞争不激烈的时候，才能修改成功。

可是如果我们的应用场景本身就是高并发的场景，就有可能导致 CAS 一直都操作不成功，这样的话，循环时间就会越来越长。而且在此期间，CPU 资源也是一直在被消耗的，这会对性能产生很大的影响。所以这就要求我们，要根据实际情况来选择是否使用 CAS，在高并发的场景下，通常 CAS 的效率是不高的。

## 范围不能灵活控制
**CAS 的第三个缺点就是不能灵活控制线程安全的范围。**

通常我们去执行 CAS 的时候，是针对某一个，而不是多个共享变量的，这个变量可能是 Integer 类型，也有可能是 Long 类型、对象类型等等，但是我们不能针对多个共享变量同时进行 CAS 操作，因为这多个变量之间是独立的，简单的把原子操作组合到一起，并不具备原子性。因此如果我们想对多个对象同时进行 CAS 操作并想保证线程安全的话，是比较困难的。

有一个解决方案，那就是利用一个新的类，来整合刚才这一组共享变量，这个新的类中的多个成员变量就是刚才的那多个共享变量，然后再利用 atomic 包中的 AtomicReference 来把这个新对象整体进行 CAS 操作，这样就可以保证线程安全。

相比之下，如果我们使用其他的线程安全技术，那么调整线程安全的范围就可能变得非常容易，比如我们用 synchronized 关键字时，如果想把更多的代码加锁，那么只需要把更多的代码放到同步代码块里面就可以了。

## 总结
本文中我们学习了 CAS 的三个缺点，分别是**ABA 问题、自旋时间过长以及线程安全的范围不能灵活控制**。

## 干货分享
**小伙伴们**关注【**码上Java**】微信公众号，回复关键字“**面试宝典**”，领取一份**嘟嘟**平时收集的一些优质资源，包含我们代码侠必备的优质简历模板、面试题库、电子书等资源大礼包一份，助力**小伙伴们**早日收获**心仪offer**,遇见更好的自己~


